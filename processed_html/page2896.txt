ASP.NET Core SignalR configuration | Microsoft Docs ASP.NET Core SignalR supports two protocols for encoding messages:  JSON  and  MessagePack . Each protocol has serialization configuration options. JSON serialization can be configured on the server using the  AddJsonProtocol  extension method.  AddJsonProtocol  can be added after  AddSignalR  in  Startup.ConfigureServices . The  AddJsonProtocol  method takes a delegate that receives an  options  object. The  PayloadSerializerOptions  property on that object is a  System.Text.Json JsonSerializerOptions  object that can be used to configure serialization of arguments and return values. For more information, see the  System.Text.Json documentation . As an example, to configure the serializer to not change the casing of property names, instead of the default  " camelCase "  names, use the following code in  Startup.ConfigureServices : In the .NET client, the same  AddJsonProtocol  extension method exists on  HubConnectionBuilder . The  Microsoft.Extensions.DependencyInjection  namespace must be imported to resolve the extension method:  Note It's not possible to configure JSON serialization in the JavaScript client at this time. If you need features of  Newtonsoft.Json  that aren't supported in  System.Text.Json , See  Switch to Newtonsoft.Json . MessagePack serialization can be configured by providing a delegate to the  AddMessagePackProtocol  call. See  MessagePack in SignalR  for more details.  Note It's not possible to configure MessagePack serialization in the JavaScript client at this time. The following table describes options for configuring SignalR hubs: Options can be configured for all hubs by providing an options delegate to the  AddSignalR  call in  Startup.ConfigureServices . Options for a single hub override the global options provided in  AddSignalR  and can be configured using  AddHubOptions : Use  HttpConnectionDispatcherOptions  to configure advanced settings related to transports and memory buffer management. These options are configured by passing a delegate to  MapHub < T >  in  Startup.Configure . The following table describes options for configuring ASP.NET Core SignalR's advanced HTTP options: The Long Polling transport has additional options that can be configured using the  LongPolling  property: The WebSocket transport has additional options that can be configured using the  WebSockets  property: Client options can be configured on the  HubConnectionBuilder  type (available in the .NET and JavaScript clients). It's also available in the Java client, but the  HttpHubConnectionBuilder  subclass is what contains the builder configuration options, as well as on the  HubConnection  itself. Logging is configured in the .NET Client using the  ConfigureLogging  method. Logging providers and filters can be registered in the same way as they are on the server. See the  Logging in ASP.NET Core  documentation for more information.  Note In order to register Logging providers, you must install the necessary packages. See the  Built-in logging providers  section of the docs for a full list. For example, to enable Console logging, install the  Microsoft.Extensions.Logging.Console  NuGet package. Call the  AddConsole  extension method: In the JavaScript client, a similar  configureLogging  method exists. Provide a  LogLevel  value indicating the minimum level of log messages to produce. Logs are written to the browser console window. Instead of a  LogLevel  value, you can also provide a  string  value representing a log level name. This is useful when configuring SignalR logging in environments where you don't have access to the  LogLevel  constants. The following table lists the available log levels. The value you provide to  configureLogging  sets the  minimum  log level that will be logged. Messages logged at this level,  or the levels listed after it in the table , will be logged.  Note To disable logging entirely, specify  signalR.LogLevel.None  in the  configureLogging  method. For more information on logging, see the  SignalR Diagnostics documentation . The SignalR Java client uses the  SLF4J  library for logging. It's a high-level logging API that allows users of the library to chose their own specific logging implementation by bringing in a specific logging dependency. The following code snippet shows how to use  java.util.logging  with the SignalR Java client. If you don't configure logging in your dependencies, SLF4J loads a default no-operation logger with the following warning message: This can safely be ignored. The transports used by SignalR can be configured in the  WithUrl  call ( withUrl  in JavaScript). A bitwise-OR of the values of  HttpTransportType  can be used to restrict the client to only use the specified transports. All transports are enabled by default. For example, to disable the Server-Sent Events transport, but allow WebSockets and Long Polling connections: In the JavaScript client, transports are configured by setting the  transport  field on the options object provided to  withUrl : In this version of the Java client websockets is the only available transport. In the Java client, the transport is selected with the  withTransport  method on the  HttpHubConnectionBuilder . The Java client defaults to using the WebSockets transport.  Note The SignalR Java client doesn't support transport fallback yet. To provide authentication data along with SignalR requests, use the  AccessTokenProvider  option ( accessTokenFactory  in JavaScript) to specify a function that returns the desired access token. In the .NET Client, this access token is passed in as an HTTP  " Bearer Authentication "  token (Using the  Authorization  header with a type of  Bearer ). In the JavaScript client, the access token is used as a Bearer token,  except  in a few cases where browser APIs restrict the ability to apply headers (specifically, in Server-Sent Events and WebSockets requests). In these cases, the access token is provided as a query string value  access_token . In the .NET client, the  AccessTokenProvider  option can be specified using the options delegate in  WithUrl : In the JavaScript client, the access token is configured by setting the  accessTokenFactory  field on the options object in  withUrl : In the SignalR Java client, you can configure a bearer token to use for authentication by providing an access token factory to the  HttpHubConnectionBuilder . Use  withAccessTokenFactory  to provide an  RxJava Single < String > . With a call to  Single.defer , you can write logic to produce access tokens for your client. Additional options for configuring timeout and keep-alive behavior are available on the  HubConnection  object itself: In the .NET Client, timeout values are specified as  TimeSpan  values. Additional options can be configured in the  WithUrl  ( withUrl  in JavaScript) method on  HubConnectionBuilder  or on the various configuration APIs on the  HttpHubConnectionBuilder  in the Java client: In the .NET Client, these options can be modified by the options delegate provided to  WithUrl : In the JavaScript Client, these options can be provided in a JavaScript object provided to  withUrl : In the Java client, these options can be configured with the methods on the  HttpHubConnectionBuilder  returned from the  HubConnectionBuilder.create( " HUB URL " ) ASP.NET Core SignalR supports two protocols for encoding messages:  JSON  and  MessagePack . Each protocol has serialization configuration options. JSON serialization can be configured on the server using the  AddJsonProtocol  extension method, which can be added after  AddSignalR  in your  Startup.ConfigureServices  method. The  AddJsonProtocol  method takes a delegate that receives an  options  object. The  PayloadSerializerSettings  property on that object is a JSON.NET  JsonSerializerSettings  object that can be used to configure serialization of arguments and return values. For more information, see the  JSON.NET documentation . As an example, to configure the serializer to use  " PascalCase "  property names, instead of the default  " camelCase "  names, use the following code in  Startup.ConfigureServices : In the .NET client, the same  AddJsonProtocol  extension method exists on  HubConnectionBuilder . The  Microsoft.Extensions.DependencyInjection  namespace must be imported to resolve the extension method:  Note It's not possible to configure JSON serialization in the JavaScript client at this time. MessagePack serialization can be configured by providing a delegate to the  AddMessagePackProtocol  call. See  MessagePack in SignalR  for more details.  Note It's not possible to configure MessagePack serialization in the JavaScript client at this time. The following table describes options for configuring SignalR hubs: Options can be configured for all hubs by providing an options delegate to the  AddSignalR  call in  Startup.ConfigureServices . Options for a single hub override the global options provided in  AddSignalR  and can be configured using  AddHubOptions : Use  HttpConnectionDispatcherOptions  to configure advanced settings related to transports and memory buffer management. These options are configured by passing a delegate to  MapHub < T >  in  Startup.Configure . The following table describes options for configuring ASP.NET Core SignalR's advanced HTTP options: The Long Polling transport has additional options that can be configured using the  LongPolling  property: The WebSocket transport has additional options that can be configured using the  WebSockets  property: Client options can be configured on the  HubConnectionBuilder  type (available in the .NET and JavaScript clients). It's also available in the Java client, but the  HttpHubConnectionBuilder  subclass is what contains the builder configuration options, as well as on the  HubConnection  itself. Logging is configured in the .NET Client using the  ConfigureLogging  method. Logging providers and filters can be registered in the same way as they are on the server. See the  Logging in ASP.NET Core  documentation for more information.  Note In order to register Logging providers, you must install the necessary packages. See the  Built-in logging providers  section of the docs for a full list. For example, to enable Console logging, install the  Microsoft.Extensions.Logging.Console  NuGet package. Call the  AddConsole  extension method: In the JavaScript client, a similar  configureLogging  method exists. Provide a  LogLevel  value indicating the minimum level of log messages to produce. Logs are written to the browser console window.  Note To disable logging entirely, specify  signalR.LogLevel.None  in the  configureLogging  method. For more information on logging, see the  SignalR Diagnostics documentation . The SignalR Java client uses the  SLF4J  library for logging. It's a high-level logging API that allows users of the library to chose their own specific logging implementation by bringing in a specific logging dependency. The following code snippet shows how to use  java.util.logging  with the SignalR Java client. If you don't configure logging in your dependencies, SLF4J loads a default no-operation logger with the following warning message: This can safely be ignored. The transports used by SignalR can be configured in the  WithUrl  call ( withUrl  in JavaScript). A bitwise-OR of the values of  HttpTransportType  can be used to restrict the client to only use the specified transports. All transports are enabled by default. For example, to disable the Server-Sent Events transport, but allow WebSockets and Long Polling connections: In the JavaScript client, transports are configured by setting the  transport  field on the options object provided to  withUrl : In this version of the Java client websockets is the only available transport. To provide authentication data along with SignalR requests, use the  AccessTokenProvider  option ( accessTokenFactory  in JavaScript) to specify a function that returns the desired access token. In the .NET Client, this access token is passed in as an HTTP  " Bearer Authentication "  token (Using the  Authorization  header with a type of  Bearer ). In the JavaScript client, the access token is used as a Bearer token,  except  in a few cases where browser APIs restrict the ability to apply headers (specifically, in Server-Sent Events and WebSockets requests). In these cases, the access token is provided as a query string value  access_token . In the .NET client, the  AccessTokenProvider  option can be specified using the options delegate in  WithUrl : In the JavaScript client, the access token is configured by setting the  accessTokenFactory  field on the options object in  withUrl : In the SignalR Java client, you can configure a bearer token to use for authentication by providing an access token factory to the  HttpHubConnectionBuilder . Use  withAccessTokenFactory  to provide an  RxJava Single < String > . With a call to  Single.defer , you can write logic to produce access tokens for your client. Additional options for configuring timeout and keep-alive behavior are available on the  HubConnection  object itself: In the .NET Client, timeout values are specified as  TimeSpan  values. Additional options can be configured in the  WithUrl  ( withUrl  in JavaScript) method on  HubConnectionBuilder  or on the various configuration APIs on the  HttpHubConnectionBuilder  in the Java client: In the .NET Client, these options can be modified by the options delegate provided to  WithUrl : In the JavaScript Client, these options can be provided in a JavaScript object provided to  withUrl : In the Java client, these options can be configured with the methods on the  HttpHubConnectionBuilder  returned from the  HubConnectionBuilder.create( " HUB URL " ) ASP.NET Core SignalR supports two protocols for encoding messages:  JSON  and  MessagePack . Each protocol has serialization configuration options. JSON serialization can be configured on the server using the  AddJsonProtocol  extension method, which can be added after  AddSignalR  in your  Startup.ConfigureServices  method. The  AddJsonProtocol  method takes a delegate that receives an  options  object. The  PayloadSerializerSettings  property on that object is a JSON.NET  JsonSerializerSettings  object that can be used to configure serialization of arguments and return values. For more information, see the  JSON.NET documentation . As an example, to configure the serializer to use  " PascalCase "  property names, instead of the default  " camelCase "  names, use the following code in  Startup.ConfigureServices : In the .NET client, the same  AddJsonProtocol  extension method exists on  HubConnectionBuilder . The  Microsoft.Extensions.DependencyInjection  namespace must be imported to resolve the extension method:  Note It's not possible to configure JSON serialization in the JavaScript client at this time. MessagePack serialization can be configured by providing a delegate to the  AddMessagePackProtocol  call. See  MessagePack in SignalR  for more details.  Note It's not possible to configure MessagePack serialization in the JavaScript client at this time. The following table describes options for configuring SignalR hubs: Options can be configured for all hubs by providing an options delegate to the  AddSignalR  call in  Startup.ConfigureServices . Options for a single hub override the global options provided in  AddSignalR  and can be configured using  AddHubOptions : Use  HttpConnectionDispatcherOptions  to configure advanced settings related to transports and memory buffer management. These options are configured by passing a delegate to  MapHub < T >  in  Startup.Configure . The following table describes options for configuring ASP.NET Core SignalR's advanced HTTP options: The Long Polling transport has additional options that can be configured using the  LongPolling  property: The WebSocket transport has additional options that can be configured using the  WebSockets  property: Client options can be configured on the  HubConnectionBuilder  type (available in the .NET and JavaScript clients). It's also available in the Java client, but the  HttpHubConnectionBuilder  subclass is what contains the builder configuration options, as well as on the  HubConnection  itself. Logging is configured in the .NET Client using the  ConfigureLogging  method. Logging providers and filters can be registered in the same way as they are on the server. See the  Logging in ASP.NET Core  documentation for more information.  Note In order to register Logging providers, you must install the necessary packages. See the  Built-in logging providers  section of the docs for a full list. For example, to enable Console logging, install the  Microsoft.Extensions.Logging.Console  NuGet package. Call the  AddConsole  extension method: In the JavaScript client, a similar  configureLogging  method exists. Provide a  LogLevel  value indicating the minimum level of log messages to produce. Logs are written to the browser console window.  Note To disable logging entirely, specify  signalR.LogLevel.None  in the  configureLogging  method. For more information on logging, see the  SignalR Diagnostics documentation . The SignalR Java client uses the  SLF4J  library for logging. It's a high-level logging API that allows users of the library to chose their own specific logging implementation by bringing in a specific logging dependency. The following code snippet shows how to use  java.util.logging  with the SignalR Java client. If you don't configure logging in your dependencies, SLF4J loads a default no-operation logger with the following warning message: This can safely be ignored. The transports used by SignalR can be configured in the  WithUrl  call ( withUrl  in JavaScript). A bitwise-OR of the values of  HttpTransportType  can be used to restrict the client to only use the specified transports. All transports are enabled by default. For example, to disable the Server-Sent Events transport, but allow WebSockets and Long Polling connections: In the JavaScript client, transports are configured by setting the  transport  field on the options object provided to  withUrl : To provide authentication data along with SignalR requests, use the  AccessTokenProvider  option ( accessTokenFactory  in JavaScript) to specify a function that returns the desired access token. In the .NET Client, this access token is passed in as an HTTP  " Bearer Authentication "  token (Using the  Authorization  header with a type of  Bearer ). In the JavaScript client, the access token is used as a Bearer token,  except  in a few cases where browser APIs restrict the ability to apply headers (specifically, in Server-Sent Events and WebSockets requests). In these cases, the access token is provided as a query string value  access_token . In the .NET client, the  AccessTokenProvider  option can be specified using the options delegate in  WithUrl : In the JavaScript client, the access token is configured by setting the  accessTokenFactory  field on the options object in  withUrl : In the SignalR Java client, you can configure a bearer token to use for authentication by providing an access token factory to the  HttpHubConnectionBuilder . Use  withAccessTokenFactory  to provide an  RxJava Single < String > . With a call to  Single.defer , you can write logic to produce access tokens for your client. Additional options for configuring timeout and keep-alive behavior are available on the  HubConnection  object itself: In the .NET Client, timeout values are specified as  TimeSpan  values. Additional options can be configured in the  WithUrl  ( withUrl  in JavaScript) method on  HubConnectionBuilder  or on the various configuration APIs on the  HttpHubConnectionBuilder  in the Java client: In the .NET Client, these options can be modified by the options delegate provided to  WithUrl : In the JavaScript Client, these options can be provided in a JavaScript object provided to  withUrl : In the Java client, these options can be configured with the methods on the  HttpHubConnectionBuilder  returned from the  HubConnectionBuilder.create( " HUB URL " ) Thank you. Send feedback about Loading feedback... Thank you. 