github baggepinnen/lowlevelparticlefilters.jl simple particle/kalman filtering smoothing and parameter estimation github is home to over 40 million developers working together to host and review code manage projects and build software together use git or checkout with svn using the web url want to be notified of new releases in baggepinnen/lowlevelparticlefilters.jl if nothing happens download github desktop and try again go back if nothing happens download github desktop and try again go back if nothing happens download xcode and try again go back if nothing happens download the github extension for visual studio and try again go back this readme is auto generated from the file src/example_lineargaussian.jl using literate.jl we provide a number of filter types this example demostrates how we set up the filters both pf and kf for a simple linear system defining a particle filter is straightforward one must define the distribution of the noise df in the dynamics function dynamics x u and the noise distribution dg in the measurement function measurement x the distribution of the initial state d0 must also be provided an example for a linear gaussian system is given below define problem define random linear state-space system the following two functions are required by the filter we are now ready to define and use a filter if you want to perform filtering using vectors of inputs and measurements try any of the functions to see how the performance varies with the number of particles we simulate several times the following code simulates the system and performs filtering using the simulated measuerments we do this for varying number of time steps and varying number of particles propagated 8400000 particles in 3.568745383 seconds for an average of 2353.7683691344473 particles per millisecond we then plot the results we also provide a particle smoother based on forward filtering backward simulation ffbs we can plot the particles themselves as well a kalman filter is easily created using the constructor many of the functions defined for particle filters are defined also for kalman filters e.g it can also be called in a loop like the pf above tuning a particle filter can be quite the challenge to assist with this we provide som visualization tools the plot displays all states and all measurements the heatmap in the background represents the weighted particle distributions per time step for the measurement sequences the heatmap represent the distibutions of predicted measurements the blue dots corresponds to measured values in this case we simulated the data and we had access to states as well if we do not have that just omit xreal .you can also manually step through the time-series using we provide som basic functionality for maximum likelihood estimation and map estimation plot likelihood as function of the variance of the dynamics noise we can do the same with a kalman filter as we can see the result is quite noisy due to the stochastic nature of particle filtering plot and compare pf and kf to solve a map estimation problem we need to define a function that takes a parameter vector and returns a particle filter the call to exp on the parameters is so that we can define log-normal priors now we call the function log_likelihood_fun that returns a function to be minimized since this is a low-dimensional problem we can plot the ll on a 2d-grid something seems to be off with this figure as the hottest spot is not really where we would expect it optimization of the log likelihood can be done by e.g. global/black box methods see blackboxoptim.jl standard tricks apply such as performing the parameter search in log-space etc this is pretty cool we procede like we did for map above but when calling the function metropolis we will get the entire posterior distribution of the parameter vector for the small cost of a massive increase in computational cost the call to exp on the parameters is so that we can define log-normal priors we also need to define a function that suggests a new point from the proposal distribution this can be pretty much anything but it has to be symmetric since i was lazy and simplified an equation if you are lucky you can run the above threaded as well i tried my best to make particle fitlers thread safe with their own rngs etc. but your milage may vary the advancedparticlefilter type requires you to implement the same functions as the regular particlefilter but in this case you also need to handle sampling from the noise distributions yourself.the function dynamics must have a method signature like below it must provide one method that accepts state vector control vector time and noise :bool that indicates whether or not to add noise to the state if noise should be added this should be done inside dynamics an example is given below the measurement_likelihood function must have a method accepting state measurement and time and returning the log-likelihood of the measurement given the state a simple example below this gives you very high flexibility the noise model in either function can for instance be a function of the state something that is not possible for the simple particlefilter to be able to simulate the advancedparticlefilter like we did with the simple filter above the measurement method with the signature measurement x t noise=false must be available and return a sample measurement given state and possibly time for our example measurement model above this would look like this we now create the advancedparticlefilter and use it in the same way as the other filters we can even use this type as an auxiliaryparticlefilter when using lowlevelparticlefilters a number of methods related to distributions are defined for static arrays making logpdf etc faster we also provide a new kind of distribution tupleproduct multivariatedistribution that behaves similarly to the product distribution the tupleproduct however stores the individual distributions in a tuple has compile-time known length and supports mixed valuesupport meaning that it can be a product of both continuous and discrete dimensions somthing not supported by the standard product example a small benchmark btime logpdf d sv 22.651 ns 0 allocations 0 bytes btime logpdf dt sv 0.021 ns 0 allocations 0 bytes btime logpdf dm sv 0.021 ns 0 allocations 0 bytes without loading lowlevelparticlefilters the timing for the native distributions are the following btime logpdf d sv 32.621 ns 1 allocation 32 bytes btime logpdf dm sv 46.415 ns 1 allocation 96 bytes this page was generated using literate.jl