sqlite json1 extension hacker news ps if you haven t looked at the sqlite source before check out their tests many of the stats on that page are impressive but the one that always gets me is that for 122 thousand lines of production code the project has 90 million lines of tests. trying to improve software quality by increasing the amount of testing is like trying to lose weight by weighing yourself more often what you eat before you step onto the scale determines how much you will weigh and the software-development techniques you use determine how many errors testing will find if you want to lose weight don x27 t buy a new scale change your diet if you want to improve your software don x27 t just test more develop better. mcconnell steve 2009-11-30 code complete kindle location 16276 microsoft press kindle edition another unique aspect of sqlite code base is total sticking to kiss http x2f x2f www.jarchitect.com x2f blog x2f p=2392 there are many cases where someone will write tests that hit an endpoint directly and then assert on the whole response which in this case is quite huge they x27 ll then do so for all branches their library x2f service x2f etc code is technically exercised sure but dothefoothing isn x27 t directly tested so it could have a bug that is only exposed from another caller with different parameters that would be caught with direct testing extreme coupling happens all the time now i x27 m slowly converting it to sanity and my teammates are copying me to be fair it was one of those get this out now because we x27 re dying kind of codebases not do to lack of skill but once code is written it s hard to undo then the bad pattern becomes keeping the same style if dothefoothing is called from somewhere else than that somewhere else should also have tests so i find that an argument from purity more than practical consideration about bug probability also if you only test dothefoothing but not the api then you could accidentally refactor yourself into breaking the api in a backwards-incompatible way or not be bug-compatible which is sometimes required or at least you should detect it and check logs and warn consumers so the api tests are needed anyway there s a balance of course if dothefoothing is an important internal cross-road or if it is algorithmically non-trivial or important for other reasons then it should be tested in seperation but between only semi-integration tests hitting endpoints and checking responses and only lots of small unit tests that break or needs rewriting for the simplest refactorings but doesn t catch subtle api breakage i d want to work with the former any day the units of code are often trivial where mistakes are not made and the mistakes comes when stringing them together and then it is more difficult to trust the human capacity to figure out failure scenarios than just run the real handlers having full unit coverage with full path coverage is a great ideal the reality is that for most companies the overhead of having and maintaining these tests is impossible from a business pov getting buy-in to spend more than 50 of your time maintaining writing updating verifying tests is a very hard sell for companies with under-staffed x2f over-worked development teams it just doesn x27 t happen at this point in my career i m firmly in the camp that functional testing is really what matters in most cases it is a compromise between the realities of business and the needs of engineering i can test the end product of the development work as a whole and identify that everything works as expected and has no known strange side-effects this also serves as a contract with your business users as to functionality of the product if bugs are discovered you can add specific use-case tests to attempt to trigger the bug and prevent regression all of this does not preclude limited unit testing as well for critical code paths i find this to be a much more pragmatic approach in the case of sqlite i think it mostly is because of hard work to fulfill the ambition to deliver a robust project and because of the existence of fuzzing which can automate test generation https x2f x2f theholyjava.wordpress.com x2f 2015 x2f 01 x2f 26 x2f challenging-mys you can test known edge case input along with the general input and it really does give you more robustness above a certain amount of tests it is maybe not the most cost-effective way to reduce defects but arguing that testing is not the way to go seems misguided to me the sqlite library consists of approximately 122.9 ksloc of c code ksloc means thousands of source lines of code or in other words lines of code excluding blank lines and comments by comparison the project has 745 times as much test code and test scripts 91596.1 ksloc though again i admire sqlite and use it my projects all the time that s not true there are multiple ways to track the progress of losing weight starting from simple look at the mirror ending with fat percent measure rich hickey x27 s _amazing_ talk on simple vs easy https x2f x2f github.com x2f matthiasn x2f talk-transcripts x2f blob x2f master x2f hi i found that pretty clear by way of it being sqlite p for one this makes debugging easier and it also means that should business needs change in the future and some field that we ve been receiving becomes important for payment processing it can be extracted from the json field and promoted to a column in the table without having to _now_ define a load of columns for every possible field that every payment provider can ever supply stuff you want to make configurable at runtime that s the issue he was referencing i think it s a shame i don t see adobe on the list of sponsors/contributers i have to say lightroom makes a huge amount of money for them however sqlite is great for ad hoc data manipulation as you say and there are application niches particularly on the client side where it can be great by itself everything i know about it is that is an excellent piece of software and the tests are practically a case study in rigor again from what i ve heard so how could you not love that they do unfortunately i inherited a web2py application using sqlite as database it was maybe ok when the original developer wrote it but it x27 s pretty clear now that we should move to a full fledged database there already were fossil columns in the database because there is no drop column and no rename column the lack of those basic features greatly hinders development because they must be implemented by creating a new table with the new schema and copying all the data in there luckily we can stop production to perform those operations but the extra developer time means that any of those operations costs an unreasonable amount of money to the customer compared to alter table drop column it x27 s not a surprise that they decided to keep those fossils into the database for now and we x27 ll see what to do another problem i run into was the typelessness of the storage basically sqlite has storage classes and maps sql types to them edit see the note at the end i quote https x2f x2f www.sqlite.org x2f datatype3.html the important idea here is that the type is recommended not required any column can still store any type of data and if numerical data is inserted into a column with text affinity it is converted into text form before being stored. i won x27 t go into details but i had some fun with dates stored in different formats in different text fields and even in the same column of the same table because different versions of a controller had different ideas about how to parse the dates received from the browser for these and other reasons we should migrating to postgresql even mysql will do that would mean rewriting parts of the application and testing it all guess if the original developer wrote any test that costs too much upfront so we x27 re sticking with sqlite for the time being until we hit some showstopper at least a problem this application won x27 t ever have is scaling there will always be one server and one process writing to the database sqlite is ok in this scenario a different web app for a different customer also inherited is using sqlite and maybe it will have to scale horizontally in the next months that means we x27 ll have to replace sqlite with postgresql but again it costs and will do it only when necessary tldr my suggestion is to never start a web application with sqlite it x27 s not its natural environment and there is little to gain because setting up a traditional database is not that difficult anyway use sqlite only as embedded db for desktop or mobile applications i wish we had it in the browser too i x27 m sorry that https x2f x2f www.w3.org x2f tr x2f webdatabase x2f has died imho it was much better than https x2f x2f www.w3.org x2f tr x2f indexeddb x2f edit i read once again the page i linked and concluded that this is because of the choice of the developer he used varchar for some date fields and numerical fields for others the problems were in the varchar fields no blame to sqlite here still automatic data conversion is not a good idea for a database imho seriously impressive database built a few ios app with it as the data store too love the zero configuration install from memory i ve even used dos batch files to manipulate data on sqlite i also use it frequently to do some data massaging before loading into a larger database since it has a standard python module and queries are quick and easy plug https x2f x2f github.com x2f facebookincubator x2f iterlib have you heard of storehaus https x2f x2f github.com x2f twitter x2f storehaus in terms of the fundamental abstraction offered it seems comparable to iterlib to me but i x27 d love to hear your opinion see also https x2f x2f upscaledb.com x2f i understand that jsonb in postgres is useful primarily for sorts and indexes does sqlite work around this somehow or is that just not included in their experiments i wasn t able to get a working build on windows i can t get the compiled json1.so to load on ubuntu 14.04 lts with stock sqlite for what is worth the sqlite3 version in ubuntu 16.04 has that json1-extension loaded by default just like mongo i was suprised to learn that mongo can actually store an object with two identical keys most drivers will prevent you from doing so and will fail to display the record fully if it does happen but it is possible