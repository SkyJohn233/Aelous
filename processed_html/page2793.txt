Message Queue: Elements and Features (Sun Java System Message Queue 3.7 UR1 Technical Overview) So far we have described the elements of message-oriented middlewareand the use of JMS as a way of adding portability to MOM applications. Itnow remains to describe how Message Queue implements the JMS specificationand to introduce the features and tools it uses to provide reliable, secure,and scalable messaging service. First, like many JMS provider, Message Queue can be used as a stand-aloneproduct or it can be used as an enabling technology, embedded in a J2EE applicationserver to provide asynchronous messaging.  Chapter 5, Message Queue and J2EE  describes the role Message Queue plays in J2EEin greater detail. Unlike other JMS providers, Message Queue has been designatedas the JMS reference implementation. This designation attests to the factthat Message Queue is a correct and complete JMS implementation. It also guaranteesthat the Message Queue product will remain current with any future JMS revisionsand extensions. As a JMS provider, Message Queue offers a  messaging service  thatimplements the JMS interfaces and that provides administrative services andcontrol. So far, in illustrating JMS providers, the focus has been mainlyon the role of the broker in relaying messages. But in fact, a JMS providermust include many elements in addition to the broker to provide reliable,secure, scalable messaging.  Figure 1 6  showsthe elements that make up the Message Queue message service. These includea variety of connection services (supporting different protocols), administrativetools, and data stores for messaging, monitoring, and user information. The Message Queue serviceitself includes all elements marked in gray in the figure. As you can see, a full-featured JMS provider is more complex than thebasic JMS model would lead one to suspect. The following sections describethe elements of the Message Queue service shown above. These elements canbe divided into three categories: the broker, client runtime support, andadministration. As shown in  Figure 1 6  both applicationclients and administration clients can connect to the broker. The JMS specificationdoes not dictate that providers implement any specific wire protocols. Message Queue services,used by application clients and administration clients to connect to the broker,are currently layered on top of TCP, TLS, HTTP, or HTTPS protocols. (Serviceslayered on top of HTTP allow messages to pass through firewalls.) Services that provide JMS support and allow clients to connectto the broker ( jms ,  ssljms ,  http ,or  https ) have a service type of  NORMAL  andare layered on top of  TCP ,  TLS ,  HTTP , or  HTTPS  protocols. Services that allow administrators to connect to the broker(  admin ,  ssladmin ) have a service typeof  ADMIN  and are layered on top of  TCP  or  TLS  protocols. By default, when you start the broker,  jms  and  admin  services are up and running. Additionally, you can configurea broker to run any or all of these connection services. Each service supportsspecific authentication and authorization (access control) features and eachservice is multi-threaded, supporting multiple connections. Should a connection fail, the Message Queue service can automaticallyretry connecting the client to the same broker or to a different broker ifthis feature is enabled. For more information, see the description of theautomatic reconnect feature in  Appendix B, Message Queue Features Clients can configure connection runtime support when they create theconnection factory from which they obtain their connections. Options allowyou to specify which brokers to connect to, how to handle reconnection, messageflow control, and so on. For additional information about how connectionscan be configured, see  Connection Factories and Connections . At the heart of the message service is the broker, which routes anddelivers messages reliably, authenticates users, and gathers data for monitoringperformance.  To route and deliver messages, the broker places incomingmessages in their respective destinations and manages message flow into andout of these destinations. To provide reliable delivery, the broker uses a persistentstore to save state information and persistent messages until they are received.Should the broker or the connection fail, the saved information allows thebroker to restore the broker s state and to retry operations. To provide security for the data being exchanged the brokeruses authenticated connections. Optionally data may be encrypted by runningover a secure protocol like SSL. The broker also uses and manages a repositorythat holds information about users and the data or operations they can access.The broker authenticates users requesting services and authorizes the operationsthey want to carry out by looking up information in this repository. To monitor the system, the broker generates metrics and diagnosticinformation that an administrator can access to measure performance and totune the broker. Metrics information is also available programmatically toallow applications to adjust message flow and patterns to improve performance. The Message Queue service provides a variety of administrative toolsthat the administrator can use to configure broker support. For more information,see  Administration . Client runtime support is provided in libraries that you link with whenbuilding Message Queue clients. You can think of the client runtime as thebit of the Message Queue service that becomes part of the client. For example,when client code makes an API call to send a message, code in these librariesis invoked that packages the message bits appropriately for the protocol thatwill be used to relay the message to the physical destination on the broker.  A JMS provider is only required to support Java clients; however, as  Figure 1 6  shows, a Message Queue client canuse either the Java or a provider-specific C API to send or receive a message.These interfaces are implemented in Java or C runtime libraries, which dothe actual work of creating connections to the broker and packaging the bitsappropriately for the connection service requested. The Java client runtime supplies Java clients with the objectsneeded to interact with the broker. These objects include connections, sessions,messages, message producers, and message consumers. The C client runtime supplies C clients with the functionsand structures needed to interact with the broker. It supports a proceduralversion of the JMS programming model. C clients cannot use JNDI to accessadministered objects, but can create connection factories and destinationsprogrammatically. The Message Queue service provides a C API to enable legacy C and C++applications to participate in JMS-based messaging. There are a number ofdifferences in the functionality provided by these two APIs; these are documentedin  Java and C Clients . It is important to remember that the JMS specification is a standardfor Java clients only. C support is specific to the Message Queue providerand should not be used in client applications that you plan to port to otherproviders. Message Queue Java clients are also able to send and receive SOAP messages,wrapped as JMS messages. SOAP (Simple Object Access Protocol) allows the exchangeof structured data between two peers in a distributed environment. The dataexchanged is specified by an XML scheme.  Sun SOAP processing is currently limited to using a point-to-point modeland does not guarantee reliability. By wrapping a SOAP message in a JMS messageand routing it using the broker, you can take advantage of full featured Message Queue messagingwhich guarantees reliable delivery and allows you to use the topic as wellas the point-to-point domain. Message Queue provides utility routines thata message producer can use to wrap a SOAP message into a JMS message and thata message consumer can use to extract a SOAP message from the JMS message. Working with SOAP Messages  gives youa more detailed view of SOAP message processing. The Message Queue service offers command line tools that you can useto do the following: Start and configure the broker. Create and manage destinations, manage broker connections,and manage broker resources. Add, list, update, and deleted administered objects in a JNDIobject store. Populate and manage a file-based user repository. Create and manage a JDBC compliant database for persistentstorage. You can also use a GUI-based administration console to perform the followingcommand-line functions: Connect to a broker and manage it. Create and manage physical destinations. Connect to an object store, add objects to the store, andmanage them. As the number of clients or the number of connections grows, you mayneed to scale the message service to eliminate bottlenecks or to improve performance.The Message Queue message service offers a number of scaling options, dependingon your needs. These may be conveniently sorted into the following categories: Vertical scaling  is achieved by addingmore processing power and by expanding available resources. You can do thisby adding more processors or memory, by switching to a shared thread model,or by running the Java VM in 64 bit mode. If you are using thepoint-to-point domain, you can scale the consumer side by allowing multipleconsumers to access a queue. Using this approach, you can specify the maximumnumber of active and backup consumers. The load-balancing mechanism also takesinto account a consumer s current capacity and message processing rate.This is a Message Queue feature. (The JMS specification defines messagingbehavior if only one consumer is accessing a queue; behavior for queues allowingmore than one consumer is provider-specific. The Message Queue developer guidesprovide more information about this scaling option.) Stateless horizontal scaling  is achievedby using additional brokers and redistributing existing clients to these brokers.This approach is easy to implement, but it is appropriate only if your messagingoperations can be divided into independent work groups. Stateful horizontal scaling  is achievedby connecting brokers into a  cluster . In a broker cluster,each broker is connected to every other broker in the cluster as well as toits local application clients. Brokers can be on the same host or distributedacross a network. Information about destinations and consumers is replicatedon all the brokers in the cluster. Updates to destinations or subscribersis also propagated Each broker can therefore route messages from producersto which it is directly connected to consumers that are connected to otherbrokers in the cluster. In situations where backup consumers are used, ifone broker or connection fails, messages sent to inaccessible consumers canbe forwarded to a backup consumers on another broker. In the eventof broker or connection failure, state information about persistent entities(destinations and durable subscriptions) can get out of sync. For example,if a clustered broker goes down and a destination is created on another brokerin the cluster, when the first broker restarts, it will not know about thenew destination. To forestall this problem, you can designate one broker inthe cluster to be the  master broker . This broker is responsiblefor tracking all changes to destinations and durable subscriptions in a  master configuration file  and for updating brokers in the clusterthat are temporarily offline. For additional information, see  Chapter 4, Broker Clusters Evenwhen using a master broker, Message Queue only provides service availability,not data availability in the case of broker or connection failure. For example,if a clustered broker becomes unavailable, any persistent messages held bythat broker become unavailable until that broker recovers. Currently, theonly means to assure data availability is through the use of a SunCluster Message Queue agent.In this case, a persistent store is kept on a shared file system. If a brokerfails the Message Queue agent on a second node starts a broker that takesover the shared store. Clients are reconnected to that broker, thereby gettingboth continuous service and access to persistent data. 