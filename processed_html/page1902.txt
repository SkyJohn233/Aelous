CN105807967A - Writing method and device for electronic whiteboard - Google Patents China 技术领域  FIELD [0001 ] 本发明涉及电子白板技术领域，特别是指一种电子白板的书写方法及装置。  [0001] Technical Field The present invention relates to the whiteboard, and particularly to a method of writing and apparatus of the copyboard. 背景技术  Background technique [0002] 电子白板，例如交互式电子白板，具备书写、批注、绘画、多媒体娱乐、网络会议等功能，融入了人机交互、平板显示、多媒体信息处理和网络传输等多项技术，是信息化时代中办公、教学、图文互动演不的优选产品。  [0002] whiteboard, such as interactive whiteboard, with writing, annotation, drawing, multimedia entertainment, web conferencing and other functions, into the human-computer interaction, flat panel display, multimedia information processing and network transmission and many other technologies, information technology era office, teaching, graphic interactive speech is not the preferred product. 目前，电子白板一般都具有一个大屏幕的交互式平板（例如为70英寸），电子白板的操作系统用于进行捕捉触点事件、绘制线条等操作。  Currently, an interactive whiteboard generally flat plate having a large screen (e.g. 70 inches) contacts capture event whiteboard operating system for drawing lines and other operations. 目前的电子白板在使用中，发现有书写体验差的问题，主要表现在书写速度慢，书写轨迹有较大偏差等，极大影响了用户的使用感受度。  The current whiteboard in use, found that the problem of poor writing experience, mainly in the slow writing speed, writing tracks have large deviation, which greatly affected the use experience of the user. 发明内容  SUMMARY [0003] 有鉴于此，本发明的目的在于提出一种电子白板的书写方法及装置，能够直接从触摸屏设备文件中得到点击的事件，直接调用底层的帧缓存接口进行写屏操作。  [0003] In view of this, an object of the present invention is to propose a method and a device for writing whiteboard, click event can be obtained directly from the touchscreen device file, directly call the bottom frame buffer write interface screen operation. [0004] 基于上述目的本发明提供一种电子白板的书写方法，包括：获取与电子白板的触摸屏相对应的触摸屏设备文件；读取所述触摸屏设备文件，从所述触摸屏设备文件中获取触摸事件数据；根据所述触摸事件数据计算在所述触摸屏上显示的轨迹数据；调用帧缓冲区接口，基于所述轨迹数据在所述触摸屏上绘制移动轨迹。  [0004] The method of providing a written whiteboard the above object of the present invention, comprising: obtaining the touch screen whiteboard touch screen device corresponding to a file; file reading the touch screen device, a touch event acquired from the touch screen device file transactions; calculating trajectory data displayed on the touch screen according to the touch event data; call interface to the frame buffer, based on the trajectory data movement trajectory drawn on the touch screen. [0005] 根据本发明的一个实施例，进一步的，启动触摸数据获取线程，所述触摸数据读取所述触摸屏设备文件，从所述触摸屏设备文件中获取触摸事件数据，并根据所述触摸事件数据计算在所述触摸屏上显示的轨迹数据；启动轨迹绘制线程，所述轨迹绘制线程调用帧缓冲区接口，基于所述轨迹数据在所述触摸屏上绘制移动轨迹。  [0005] According to one embodiment of the present invention, further, the data acquisition start thread touch, the touch data file reading the touch screen device, a touch event data acquired from the touch screen device file, and according to the touch event data calculating trajectory data displayed on the touch screen; locus drawing start thread, the thread draw call frame trace buffer interface based on said movement trajectory in the trajectory data drawn on the touch screen. [0006] 根据本发明的一个实施例，进一步的，所述获取与电子白板的触摸屏相对应的触摸屏设备文件包括：打开系统中存储设备文件的目录，遍历此目录下所有的设备文件；依次打开设备文件，得到此设备文件的句柄并获取此设备文件的设备名称；判断此设备文件的设备名称是否与所述触摸屏设备的设备名称一致，如果是，则此设备文件为所述触摸屏设备文件，保存所述触摸屏设备文件的句柄。  [0006] According to one embodiment of the present invention, further, the acquiring whiteboard touch screen corresponding to the touch screen device file comprising: Open the directory stored in the system device files, through all the device files in this directory; turn open the device file, to obtain a handle to the device file and acquires the device name of the device file; device name Analyzing device file is consistent with the device name of the touch screen device, if it is, the device file as the touch screen device file, save handle the touch screen device file. [0007] 根据本发明的一个实施例，进一步的，所述读取所述触摸屏设备文件、从所述触摸屏设备文件中获取触摸事件数据包括：周期性地读取所述触摸屏设备文件，获取所述触摸屏设备文件中的事件数据；其中，在所述触摸屏上操作的事件数据被存储在所述触摸屏设备文件中；解析所述事件数据，并将所述事件数据封装为所述触摸屏上的移动轨迹的坐标数据。  [0007] According to one embodiment of the present invention, further, the file reading the touch screen device, a touch event data acquired from the touch screen device comprises a file: periodically reading the touch screen device file, acquires the said touch screen event data file device; wherein the event data on the touch panel operation is stored in the touch screen device file; parsing the event data and the event data package to the mobile on the touch screen coordinate data tracks. [0008] 根据本发明的一个实施例，进一步的，所述解析所述事件数据、并将所述事件数据封装为在所述触摸屏上移动的轨迹的坐标数据包括：解析所述事件数据获取事件参数，所述事件参数包括：事件ID、操作类型、X坐标采样值、Y坐标采样值；将所述事件参数转换为移动轨迹的坐标数据，所述坐标数据包括：轨迹ID、触摸屏X坐标、触摸屏y坐标和当前操作状态；所述当前操作状态包括：上、下、移动；其中，当触摸屏的分辨率为在X轴方向上为W像素、在Y轴方向上为Η像素时：  Coordinate data [0008] According to an embodiment of the present invention, further, the analysis of the event data, the event data package and to move in the track on the touch screen comprises: parsing the event data acquisition event parameters, parameters of the event comprises: event ID, type of, sample values ​​of the X coordinate, Y coordinate values ​​of the sample; converting the coordinate data of the event parameter is a movement locus of the coordinate data comprising: a track ID, a touch screen coordinate X, y coordinate of the touch screen and the current operating state; the current operating state comprising: upper and lower, moved; wherein, when the resolution of the touch screen is, when the X-axis direction is W pixels in the Y-axis direction pixel Η: [0009]  [0009] [0010] XL为触摸屏X标，XT为X坐标采样值，Xtmin、Xtmax、分别是触摸屏的X、Υ轴方向上的坐标最小值和坐标最大值；  [0010] XL X marked as a touch screen, XT coordinate for the sample value X, Xtmin, Xtmax, respectively, the touch screen X, coordinates of the minimum and maximum coordinates in the Υ-axis direction; [0011]  [0011] [0012] YL为触摸屏Y坐标，YT是Y坐标采样值，Ytmin、Ytmax分别是触摸屏的Y轴方向上的坐标最小值和坐标最大值。  [0012] YL Y coordinate for the touch screen, YT is a Y coordinate sampling values, Ytmin, Ytmax coordinates are the coordinates of the minimum and maximum values ​​on the Y-axis direction of the touch screen. [0013] 根据本发明的一个实施例，进一步的，所述调用帧缓冲区接口、基于所述轨迹数据在所述触摸屏上绘制移动轨迹包括：基于触摸屏的像素设置绘图区域，在内存中创建与所述绘图区域相映射图文件对象；基于所述坐标数据在所述图文件对象中加入在所述触摸屏上绘制的移动轨迹数据；打开一个可用的帧缓冲设备，获取取得当前的所述触摸屏的参数，所述触摸屏的参数包括：屏幕分辨率、每个像素点的比特数；将所述帧缓冲设备的内存映射到内核进程空间；将所述图文件对象的数据写入所述帧缓冲设备的内存，通过所述帧缓冲设备在所述触摸屏上相应的位置绘制并显示移动轨迹。  [0013] According to one embodiment of the present invention, further, the call interface to the frame buffer, based on the trajectory data movement trajectory drawn on the touch screen comprises: creating in the memory a pixel is provided based on the drawing area of ​​the touch screen and the map drawing area with file objects; data added trajectories drawn on the touch screen in the FIG file object based on the coordinate data; open frame buffer available device, acquires the current acquisition of the touch screen parameters, parameters of the touch screen comprising: a screen resolution, the number of bits per pixel; the apparatus frame buffer memory space mapped to the kernel process; FIG writing data to the file object of the frame buffer device memory apparatus by said frame buffer and a display position corresponding to the movement locus drawn on the touch screen. [0014] 基于上述目的本发明提供一种电子白板的书写装置，包括：设备文件获取单元， 用于获取与电子白板的触摸屏相对应的触摸屏设备文件；轨迹数据计算单元，用于读取所述触摸屏设备文件，从所述触摸屏设备文件中获取触摸事件数据；根据所述触摸事件数据计算在所述触摸屏上显示的轨迹数据；轨迹绘制单元，用于调用帧缓冲区接口，基于所述轨迹数据在所述触摸屏上绘制移动轨迹。  [0014] Based on the above-described object of the present invention provides an electronic whiteboard writing apparatus, comprising: a device file acquiring means for acquiring a touch screen whiteboard touch screen device corresponding file; trajectory data calculation unit for reading the the touch screen device file, acquired from the touch screen in a touch event data file device; calculating trajectory data displayed on the touch screen according to the touch event data; locus drawing means for invoking the interface frame buffer, based on the trajectory data movement trajectory drawn on the touch screen. [0015] 根据本发明的一个实施例，进一步的，所述轨迹数据计算单元，用于启动触摸数据获取线程；其中，所述触摸数据读取所述触摸屏设备文件，从所述触摸屏设备文件中获取触摸事件数据，并根据所述触摸事件数据计算在所述触摸屏上显示的轨迹数据；所述轨迹绘制单元，用于启动轨迹绘制线程；其中，所述轨迹绘制线程调用帧缓冲区接口，基于所述轨迹数据在所述触摸屏上绘制移动轨迹。  [0015] According to an embodiment of the present invention, further, the trajectory data calculation unit for acquiring thread start touch data; wherein, the touch of the touch screen device data file read from the touch screen device file acquiring a touch event data, and calculates the trajectory data displayed on the touch screen according to the touch event data; the locus drawing means for drawing the thread start track; wherein the locus drawing frame buffer thread calls the interface, based on the data is plotted movement trajectory in the trajectory on the touch screen. [0016] 根据本发明的一个实施例，进一步的，所述设备文件获取单元，还用于打开系统中存储设备文件的目录，遍历此目录下所有的设备文件；依次打开设备文件，得到此设备文件的句柄并获取此设备文件的设备名称；判断此设备文件的设备名称是否与所述触摸屏设备的设备名称一致，如果是，则此设备文件为所述触摸屏设备文件，保存所述触摸屏设备文件的句柄。  [0016] According to one embodiment of the present invention, further, the device file acquisition unit, the directory file system of the storage device is further configured to open through all the device files in this directory; turn open the device file, to obtain the device file handle and acquires the device name of the device file; device name Analyzing device file is consistent with the device name of the touch screen device, if it is, the device file as the touch screen device file, saving the touch screen device file It handles. [0017] 根据本发明的一个实施例，进一步的，所述轨迹数据计算单元，包括：事件获取子模块，用于周期性地读取所述触摸屏设备文件，获取所述触摸屏设备文件中的事件数据；其中，在所述触摸屏上操作的事件数据被存储在所述触摸屏设备文件中；坐标计算子模块，用于解析所述事件数据，并将所述事件数据封装为所述触摸屏上的移动轨迹的坐标数据。  [0017] According to one embodiment of the present invention, further, the trajectory data calculation unit comprises: an event acquisition sub-module for periodically reading the touch screen device file, acquires the touchscreen device file events data; wherein, the event data on the touch panel operation is stored in a file, the touch screen device; movement on the touch screen coordinate calculation sub-module, for parsing the event data and the event data packaged into coordinate data tracks. [0018] 根据本发明的一个实施例，进一步的，所述坐标计算单元，还用于解析所述事件数据获取事件参数，所述事件参数包括：事件ID、操作类型、X坐标采样值、Y坐标采样值；将所述事件参数转换为移动轨迹的坐标数据，所述坐标数据包括：轨迹ID、触摸屏X坐标、触摸屏y坐标和当前操作状态；所述当前操作状态包括：上、下、移动；其中，当触摸屏的分辨率为在X轴方向上为W像素、在Y轴方向上为Η像素时：  [0018] According to an embodiment of the present invention, further, the coordinate calculation unit is further configured to parse the event data acquisition event parameters, parameters of the event comprises: event ID, type of, X-coordinate values ​​of the sampling, Y coordinates value; converting the coordinate data of the event parameter is a movement locus of the coordinate data comprising: a track ID, X-coordinate of a touch screen, a touch screen and a y coordinate of the current operating state; the current operating state comprising: upper and lower, moved ; wherein, when, when Η pixel resolution of the touch screen in the X-axis direction is W pixels in the Y-axis direction: [0019]  [0019] [0020] XL为触摸屏X标，XT为X坐标采样值，Xtmin、Xtmax、分别是触摸屏的X、Υ轴方向上的坐标最小值和坐标最大值；  [0020] XL X marked as a touch screen, XT coordinate for the sample value X, Xtmin, Xtmax, respectively, the touch screen X, coordinates of the minimum and maximum coordinates in the Υ-axis direction; [0021]  [0021] [0022] YL为触摸屏Y坐标，YT是Y坐标采样值，Ytmin、Ytmax分别是触摸屏的Y轴方向上的坐标最小值和坐标最大值。  [0022] YL Y coordinate for the touch screen, YT is a Y coordinate sampling values, Ytmin, Ytmax coordinates are the coordinates of the minimum and maximum values ​​on the Y-axis direction of the touch screen. [0023] 根据本发明的一个实施例，进一步的，所述轨迹绘制单元，包括：图文件创建子模块，用于基于触摸屏的像素设置绘图区域，在内存中创建与所述绘图区域相映射图文件对象；运行轨迹生成子模块，用于基于所述坐标数据在所述图文件对象中加入在所述触摸屏上绘制的移动轨迹数据；帧缓冲设备调用子模块，用于打开一个可用的帧缓冲设备，获取取得当前的所述触摸屏的参数，所述触摸屏的参数包括：屏幕分辨率、每个像素点的比特数； 将所述帧缓冲设备的内存映射到内核进程空间；将所述图文件对象的数据写入所述帧缓冲设备的内存，通过所述帧缓冲设备在所述触摸屏上相应的位置绘制并显示移动轨迹。  [0023] According to one embodiment of the present invention, further, the locus drawing means, comprising: a sub-module of FIG file creation, based on the pixel drawing area setting of the touch screen, created in memory mapped region of the drawing of FIG. file object; trajectory generation sub-module, based on the coordinate data added to the moving route data drawn on the touch screen in the FIG file object; framebuffer device sub-module call, are available for opening a frame buffer equipment, to obtain a current parameter obtaining the touch screen, the touch screen parameters comprises: screen resolution, number of bits per pixel; and the frame buffer memory-mapping process space to the kernel; the FIG file data objects written to said frame buffer memory device, and a position corresponding to the drawing movement locus displayed on the touch screen by the frame buffer device. [0024] 从上面所述可以看出，本发明的电子白板的书写方法及装置，能够直接从触摸屏设备文件中得到点击的事件，直接调用底层的帧缓存接口进行写屏操作，并将获取触摸事件和写屏操作分别放在2个线程完成的，提高了运行效率并提升书写速度，解决了书写轨迹偏差的问题，并明显提升了显示数据的速度。  [0024] As can be seen from the above, the writing method and apparatus of the copyboard of the present invention can be obtained directly from the click event touchscreen device file, directly call the underlying screen frame buffer interface write operation, the acquired touch events and write operations respectively on the screen to complete the two threads, to improve operating efficiency and enhance the writing speed, writing to solve the problem of route deviation, and significantly enhance the speed of display data. 附图说明  BRIEF DESCRIPTION [0025] 图1为本发明的电子白板的书写方法的一个实施例的流程图；  Writing method [0025] FIG copyboard a flow diagram of the present invention embodiment; [0026] 图2为Android系统架构图；  [0026] FIG. 2 is a system architecture diagram Android; [0027] 图3本发明的电子白板的书写方法的并行处理示意图；  [0027] The method of writing parallel whiteboard Figure 3 a schematic view of a process of the present invention; [0028] 图4为Android⑶I系统架构图；  [0028] FIG. 4 is a system architecture diagram Android⑶I; [0029] 图5为Android⑶I的总体结构图；  [0029] FIG. 5 is a general configuration diagram of Android⑶I; [0030] 图6为本发明的电子白板的书写装置的一个实施例的示意图。  A schematic of an embodiment of a writing apparatus of the copyboard [0030] FIG. 6 of the present invention. 具体实施方式  Detailed ways [0031] 为使本发明的目的、技术方案和优点更加清楚明白，以下结合具体实施例，并参照附图，对本发明进一步详细说明。  [0031] To make the objectives, technical solutions, and advantages of the present invention will become more apparent hereinafter in conjunction with specific embodiments, and with reference to the accompanying drawings, the present invention is described in further detail. [0032] 图1为本发明的电子白板的书写方法的一个实施例的流程图，如图1所示：  [0032] FIG. 1 is a flowchart of one embodiment of a method of writing whiteboard present invention, shown in Figure 1: [0033] 步骤101，获取与电子白板的触摸屏相对应的触摸屏设备文件。  [0033] Step 101, acquires the touch screen whiteboard touch screen corresponding device file. [0034] 步骤102,读取触摸屏设备文件，从触摸屏设备文件中获取触摸事件数据。  [0034] Step 102, the touch screen device file is read, acquiring a touch event data from the touchscreen device file. [0035] 步骤103,根据触摸事件数据计算在触摸屏上显示的轨迹数据。  [0035] Step 103, the trajectory data displayed on the touch screen according to the touch event data is calculated. [0036] 步骤104,调用帧缓冲区接口，基于轨迹数据在触摸屏上绘制移动轨迹。  [0036] Step 104, the interface call frame buffer, the movement trajectory drawn on the touch screen based on the trajectory data. [0037] 上述实施利中的电子白板的书写方法，能够较好地解决了书写速度的问题，而且能够解决了书写轨迹偏差的问题。  Writing Method [0037] The advantage of the embodiment whiteboard, can solve the problem of writing speed, and can solve the problem of writing the track deviation. [0038] 目前，电子白板可以基于多种操作系统，例如linux、android等。  [0038] Currently, the copyboard may be based on a variety of operating systems such as linux, android like. 以android框架实现为例，android系统架构如图2所示。  Android framework to implement an example, android system architecture shown in Figure 2. 采用这种Android系统架构，经过测试发现，从触摸屏touch panel驱动发出某个点的采样值到上层应用程序取得点坐标，大约需要15ms 到18ms〇  With this Android system architecture been tested and found to drive the value of a sample sent to the upper point of application to obtain coordinates from the touch-screen touch panel, it takes about 15ms to 18ms〇 [0039] 在目前的电子白板的android系统架构中，取触摸事件和屏幕绘图刷新都是在一个主线程完成的，这种架构必须串行完成所有工作，处理效率低下，造成书写速度缓慢。  [0039] In the android system architecture of the current whiteboard, take a touch event and refreshes the screen drawing is done in a main thread completed, this serial architecture must all work, inefficient processing, resulting in a slow writing speed. [0040] 在一个实施例中，将串行处理改为并行处理，提升效率，如下图3所示，启动触摸数据获取线程，触摸数据读取触摸屏设备文件，从触摸屏设备文件中获取触摸事件数据，并根据触摸事件数据计算在触摸屏上显示的轨迹数据；启动轨迹绘制线程，轨迹绘制线程调用帧缓冲区接口，基于轨迹数据在触摸屏上绘制移动轨迹。  [0040] In one embodiment, the serial to parallel processing process, improve efficiency, as shown below, the data acquisition start thread 3 touch, touch the touch screen data reading device file, acquires a touch event data from the touchscreen device file and calculating the data according to a touch event on the touch screen display in the trajectory data; locus drawing the thread start, thread calls locus drawing frame buffer interface, a movement trajectory drawn on the touch screen based on the trajectory data. 将获取触摸事件的功能和显示的功能分别由2个线程分别完成，能够提高电子白板的书写速度。  Will get a touch event functions and display functions are performed by two threads respectively, can improve the speed of writing whiteboard. [0041 ] 在现有的android系统架构中，触摸事件处理层次如下表1所示，从一个触摸事件产生到应用程序收到此点的事件，中间需要经过很多步骤，这个过程就是导致延时15ms到18ms的原因。  [0041] In the conventional system architecture android touch event processing levels are shown in Table 1, is generated from a touch event to the event received by the application at this point, need to go through many intermediate steps, this process resulting in latency is 15ms to the cause of 18ms. [0042]  [0042] [0043] 表1-触摸事件处理层次表  [0043] Table 1 - touch table-level event handling [0044] 在一个实施例中，直接从触摸屏驱动touch panel driver得到点击的事件。  [0044] In one embodiment, the touch screen driven directly from the touch panel driver to give a click event. 在android系统中，所有的设备都是被抽象为文件，可以通过jni的方式用C语言写一个直接读取触摸屏Touch Panel输入设备事件的程序，来从底层直接取触摸事件并按照相应的协议转换后将事件直接分发给上层应用使用。  In android system, all devices are abstracted as a file is to be written in C language by way of a direct read jni touchscreen input device Touch Panel program event, a touch event to take directly from the ground and follow the protocol conversion after the event distributed directly to the upper application use. [0045] 在android系统中，普通应用程序是无法直接读取触摸屏Touch Panel抽象设备文件，需要首先将应用程序加system权限并在Android源码中编译，然后在程序中获得root权限，然后再遍历/dev/input目录，得到所有的设备文件，并使用chmod命令修改权限为666 (只读），再读取此设备的名称，找到对应的Touch Panel设备再读取事件。  [0045] In the android system, common applications are not read directly from the touch screen Touch Panel abstract device file, you need the application plus system privileges and compile Android source code, and then get root privileges in the program, and then traverse / dev / input directory, get all the device files, and use the chmod command to modify the permissions to 666 (read-only), and then read the name of this device, find the corresponding Touch Panel device then reads the event. 具体为：  Specifically: [0046] 1.获得root 权限。  [0046] 1. Obtain root privileges. [0047] 2.遍历/dev/input目录，得到每个设备号。  [0047] 2. traversal / dev / input directory, to give each device number. [0048] 3.使用chmod将此设备权限修改为666。  [0048] 3. Use chmod 666 device permissions to modify this. [0049] 4.使用open方式以只读方式打开此设备。  [0049] 4. The open mode using open read-only device. [0050] 5.使用ioctl得到此设备的名称，判断是否是Touch Panel设备。  [0050] 5. The ioctl obtained name of the device, the device determines whether the Touch Panel. [0051] 6.找到对应的Touch Panel设备，返回设备文件号。  [0051] 6. Find the corresponding Touch Panel device and returns the device file number. [0052] 7.循环读取设备事件，得到事件结构体。  [0052] 7. A reading apparatus cycle events, the event structure is obtained. [0053] 8.按照多点触控协议解析得到的事件。  [0053] 8. The multi-touch event protocol analysis obtained. [0054] 9.在应用程序的AndroidManifest. xml 中加入android: sharedUserld =  " android, uid. system〃属性，以提升应用程序权限。  . [0054] 9. xml added in android AndroidManifest application:. SharedUserld =  " android, uid system〃 properties, to enhance application permissions. [0055] 10.将应用程序在Android源码中编译得到相应的APK文件。  [0055] 10. The application files provide the corresponding APK Android compile source code. [0056] 从触摸屏Touch Panel设备文件中读取的数据是触摸屏采用数据，不是IXD坐标值，需要采用类似于屏幕校正算法的方式先转换为LCD坐标才能提供给应用上层使用。  [0056] The data read from the touch screen Touch Panel device file data using a touch screen, not IXD coordinate values, in a manner similar need correction algorithm screen LCD coordinates can be converted to an upper layer to the application used. [0057] 在一个实施例中，打开系统中存储设备文件的目录，此目录可以根据电子白板支持不同的操作系统而不同，例如，android系统为/dev/input目录。  [0057] In one embodiment, open the directory file system of the storage device, according to this directory whiteboard support different operating systems differ, e.g., android system / dev / input directory. 遍历此目录下所有的设备文件，依次打开设备文件，得到此设备文件的句柄并获取此设备文件的设备名称。  Through all device files in this directory, open the device file, get a handle on this device file and obtain the device name for this device file. [0058] 判断此设备文件的设备名称是否与触摸屏设备的设备名称一致，如果是，则此设备文件为触摸屏设备文件，保存触摸屏设备文件的句柄。  [0058] determine the device name for this device file is consistent with the device name touch screen devices, if it is, the device file for the touch screen device file, save the file handle touch-screen devices. 根据电子白板支持不同的操作系统，可以使用不同的系统提供的函数执行上述功能，也可以开发专门的函数。  According whiteboard support different operating systems, you can use different functions provided by the system to perform the above functions, can also develop specialized functions. [0059] 例如，在android系统中，循环读取设备文件，得到事件结构体具体为：  [0059] For example, in android system, the circulation document reading apparatus, the event structure is obtained specifically as follows: [0060] 得到触摸屏TouchPanel设备文件句柄。  [0060] TouchPanel get a touch screen device file handle. 具体步骤如下：  Specific steps are as follows: [0061] a.使用opendir函数打开/dev/input目录，得到目录句柄。  [0061] a. Use opendir function to open / dev / input directory, the directory to obtain the handle. [0062] b.使用readdir函数遍历读取此目录下所有设备文件。  [0062] b. Readdir function using the traverse device reads all files in this directory. [0063] c.使用open函数打开设备文件，得到文件句柄。  [0063] c. Using the file open function to open the device to obtain a file handle. [0064] d.使用ioctl函数得到此设备文件的设备名称。  [0064] d. Ioctl function obtained using the device file name of the device. [0065] e.使用strcmp函数比较此设备文件的设备名称和电子白板使用的触摸屏TouchPanel设备名称是否一致，如果一致，保存此设备文件句柄，并跳出遍历循环，否则继续遍历。  [0065] e. TouchPanel touch screen device name using the strcmp function to compare this device file name of the device and whiteboard use is consistent, if consistent, save the device file handle and jumped out through the loop, otherwise continue traversal. [0066] 循环读取设备文件、得到事件结构体实现的部分代码如下：  [0066] to read the device file, to obtain part of the code structure to achieve the following events: [0067]  [0067] [0068]  [0068] [0069] 使用read函数循环读取刚才保存的设备文件，第二个参数event返回的就是时间结构体。  [0069] The read function using the loop just saved file reading apparatus, the second argument is returned event time structure. [0070]  [0070] [0071] 在一个设备中，周期性地、循环读取触摸屏设备文件，获取触摸屏设备文件中的事件数据。  [0071] In one apparatus, periodically, the touch screen device file read cycle, the touch screen device acquires event data file. 在触摸屏上操作的事件数据被存储在触摸屏设备文件中。  Event data on a touch-screen operation is stored in the touch screen device file. 解析事件数据，并将事件数据封装为触摸屏上的移动轨迹的坐标数据。  Parsing the event data and event data package to the coordinate data of the movement trajectory on the touch screen. [0072] 例如，在android系统中，按照多点触控协议解析得到的事件，并封装数据的例子如下：  [0072] For example, in the android system according multitouch protocol parsing events obtained, and the encapsulated data is an example as follows: [0073] 用户在触摸屏幕上点击一下后硬件产生一个中断，OnClickListener收到这个事件，往/dev/input/event*写入一个相应的事件数据，android循环读取/dev/input/ event*的事件，再分发给WindowManagerServer，最后再发到相应的ViewGroup和View。  [0073] the user clicks on the touch screen at the hardware generates an interrupt, OnClickListener receive this event, to / dev / input / event * write a corresponding event data, android cycle read / dev / input / event * of event, and then distributed WindowManagerServer, and finally sent to the appropriate ViewGroup and View. 可以通过直接读取/dev/input/event*事件数据的方式，来达到快速处理的目的。  Can directly read / dev / input / event * way of event data, to achieve the purpose of rapid processing. [0074] 读取/dev/input/event*中的事件数据，如下所示：  [0074] The read / dev / input / event * event data as follows: [0075] /dev/input/event4:0003 0039 0000000d  [0075] / dev / input / event4: 0003 0039 0000000d [0076] /dev/input/event4:0003 0035 00006e25  [0076] / dev / input / event4: 0003 0035 00006e25 [0077] /dev/input/event4:0003 0036 00002ecb  [0077] / dev / input / event4: 0003 0036 00002ecb [0078] /dev/input/event4:0000 0002 00000000  [0078] / dev / input / event4: 0000 0002 00000000 [0079] /dev/input/event4:0003 0039 00000002  [0079] / dev / input / event4: 0003 0039 00000002 [0080] /dev/input/event4:0003 0035 00006ea4  [0080] / dev / input / event4: 0003 0035 00006ea4 [0081] /dev/input/event4:0003 0036 000028c2  [0081] / dev / input / event4: 0003 0036 000028c2 [0082] /dev/input/event4:0000 0002 00000000  [0082] / dev / input / event4: 0000 0002 00000000 [0083] /dev/input/event4:0000 0000 00000000  [0083] / dev / input / event4: 0000 0000 00000000 [0084] /dev/input/event4:0003 0039 OOOOOOOd  [0084] / dev / input / event4: 0003 0039 OOOOOOOd [0085] 第一列数据/dev/input/event4:表示TouchPanel 设备文件是event4。  [0085] The first column / dev / input / event4: TouchPanel device file represents a event4. 第二列数据：0003表示这是一个TouchPanel点击事件，0000表示这是一个同步信号，意思就是事件结束，可以解析并且分发出去了。  The second column of data: 0003 indicates that this is a click event TouchPanel, 0000 indicates that this is a synchronous signal, meaning that the event is over, you can parse and distribute out. 第三列数据：0039表示第四列数据是哪个点触摸事件发生了，0035表示第四列数据是X坐标采样值，0036表示第四列数据是Y坐标采样值。  The third column of data: 0039 data which represent fourth column touch event occurs, the data 0035 represents the fourth column is the X coordinate sampling value 0036 represents the fourth column is the Y coordinate data samples. 0000 0002 00000000、0000 0000 00000000表示此点抬起了，如果再跟着有0000 000200000000、0000 0000 00000000 表示所有点都抬起了。  00,000,002 00000000,0000 000 billion indicates that the point raised, and if there is then followed by 0000 000200000000,0000 000 billion means that all points are lifted. [0086] 根据对event读取数据的分析，封装数据格式，例如定义如下类：  [0086] The analysis of Event data read, data encapsulation format, for example, the class is defined as follows: [0087] public class MyEvent  [0087] public class MyEvent [0088] {  [0088] { [0089] private int[] id = null ; //保存点的需要，对应上述第四列数据  [0089] private int [] id = null; // needs savepoint, data corresponding to the fourth column [0090] private float[]x = null ; // 保存转换过的IXD x 坐标  [0090] private float [] x = null; // save the converted coordinate IXD x [0091] private float[]y = null ; // 保存转换过的IXD y 坐标  [0091] private float [] y = null; // save the converted IXD y coordinate [0092] private int [] status = null ; //保存当前的状态：down、move、up  [0092] private int [] status = null; // save the current state: down, move, up [0093] }  [0093]} [0094] 从event*中读取相应的数据按照上述的分析方法将MyEvent需要的几个变量值填入，然后上层程序取得相应的数据绘图即可。  [0094] reads the corresponding data according to the above analytical method MyEvent required values ​​into several variables, then the program upper drawing to obtain the corresponding data from the event *. [0095] 在一个实施例中，解析事件数据获取事件参数，事件参数包括：事件ID、操作类型、X坐标采样值、γ坐标采样值。  [0095] In one embodiment, the parsed event data acquisition event parameters, event parameters include: event ID, type of, X-coordinate values ​​of the sampling, gamma] coordinate samples. 将事件参数转换为移动轨迹的坐标数据，坐标数据包括： 轨迹ID、触摸屏X坐标、触摸屏y坐标和当前操作状态；当前操作状态包括：上、下、移动。  Converting the event parameter is the movement trajectory coordinate data, coordinate data comprising: a track ID, X-coordinate of a touch screen, a touch screen and a y coordinate of the current operating state; current operating state comprising: upper, lower, move. [0096] 当触摸屏的分辨率为在X轴方向上为W像素、在Y轴方向上为Η像素时：  [0096] When resolution of the touch screen is, when the X-axis direction is W pixels in the Y-axis direction pixel Η: [0097]  [0097] [0098] XL为触摸屏X标，XT为X坐标采样值，Xtmin、Xtmax、分别是触摸屏的X、Υ轴方向上的坐标最小值和坐标最大值；  [0098] XL X marked as a touch screen, XT coordinate for the sample value X, Xtmin, Xtmax, respectively, the touch screen X, coordinates of the minimum and maximum coordinates in the Υ-axis direction; [0099]  [0099] [0100] YL为触摸屏Y坐标，YT是Y坐标采样值，Ytmin、Ytmax分别是触摸屏的Y轴方向上的坐标最小值和坐标最大值。  [0100] YL Y coordinate for the touch screen, YT is a Y coordinate sampling values, Ytmin, Ytmax coordinates are the coordinates of the minimum and maximum values ​​on the Y-axis direction of the touch screen. [0101] 从触摸屏TouchPanel设备文件中读取出的值为触摸屏的采样值，不是触摸屏的IXD的坐标值，所以必须作一个类似校正的算法转换为需要的IXD坐标值才能使用。  IXD coordinate values ​​of the [0101] sample values ​​read from the file device TouchPanel touchscreen touch screen is not a touch screen, it is necessary to make a similar correction algorithm is converted to coordinate values ​​need to use IXD. [0102] tp坐标到led坐标是完全按照线性关系来转换的。  [0102] tp coordinates led to fully coordinate transformation in a linear relationship. 例如，tp坐标是（Xt, Yt)分辨率是（Wt X Ht)，led 坐标是（X，Y)，分辨率是（WX Η)，则X = (Xt*W) /Wt,Y = (Yt*H) /Ht。  For example, tp coordinates (Xt, Yt) resolution (Wt X Ht), led coordinates (X, Y), the resolution is (WX Η), then X = (Xt * W) / Wt, Y = ( Yt * H) / Ht. 但是一般触摸屏不是完全线性的，自然转换关系也就不一样了，通过tslib可以解决这个问题。  But in general the touch screen is not perfectly linear, natural transition relationship is not the same, can solve this problem by tslib. 需要其中根据采样点生成转换矩阵的部分编写转换算法即可。  Wherein part of the preparation required to generate the transformation matrix conversion algorithm according to the sampling point. 具体算法如下：  The algorithm is as follows: [0103]  [0103] [0104]  [0104] > : > : [0105] 其中，XL、YL 是IXD 坐标，XT、YT 是触摸屏的坐标。  [0105] wherein, XL, YL coordinate is IXD, XT, YT are the coordinates of a touch screen. Xtmin、Xtmax、Ytmin、Ytmax 分别是触摸屏的X、Y轴方向上的最小值和最大值。  Xtmin, Xtmax, Ytmin, Ytmax touch screen are X, minimum and maximum values ​​on the Y-axis direction. [0106] Android⑶I系统架构如图4所示，Android的⑶I系统由C语言框架和JAVA语言框架组成。  [0106] Android⑶I system architecture shown in Figure 4, Android ⑶I system of the C language and JAVA language frame framework. 对下层，Android的⑶I系统通过调用显示输出设备和输入设备的驱动，从而将Android的软件系统和底层的硬件联系起来。  The lower layer, the Android ⑶I system display drive an output device and an input device by calling, so that the Android software system and the underlying hardware link. 对上层，Android的⑶I系统提供了Java 层次的绘图结构，Android的Java框架层调用这些绘图接口来构建各种UI元素，这些绘图接口也可以供Java应用程序层来调用。  An upper layer, the Android ⑶I system provides a hierarchical drawing structure Java, Java frame layer Android graphics interface call these various UI elements to build, which may be graphics interface for the Java application layer call. [0107] Surface Manager是用户空间中framework下libraries中负责显不相关的一个模块，当系统同时执行多个应用程序时，SurfaceManager会负责管理显示与存取操作间的互动，另外也负责将2D绘图与3D绘图进行显示上的合成。  [0107] Surface Manager is a user space module libraries are responsible for the significant irrelevant Framework, when the system is executing a plurality of applications simultaneously, SurfaceManager will be responsible for managing the interaction between the display and the access operation, while also responsible for drawing 2D synthesized and 3D graphics on the display. SurfaceManager图形系统采用Client/Server 架构：  SurfaceManager graphics system using Client / Server architecture: [0108] Client端：应用程序相关部分。  [0108] Client side: related applications section. 代码分为两部分，一部分是由Java提供的供应用使用的api，另一部分则是由C++写成的底层实现。  Code is divided into two parts by the supply provided by using Java api, the other part is written in C ++ by the underlying implementation. [0109] Server端：即SurfaceFlinger，负责合成并送入buffer显示。  [0109] Server-side: that SurfaceFlinger, responsible for the synthesis and sent to the display buffer. 其主要由C++代码编写而成。  The main written in the C ++ code. [0110] Client和Server之间通过Binder的IPC方式进行通信，总体结构图如图5所示：Surface的client部分其实是提供给各应用程序进行画图操作的一个桥梁，该桥梁通过binder 通向server 端的Surfaceflinger。  [0110] communication between the Client and the Server, the general structure shown in Figure 5 by way of Binder of IPC: client part Surface actually available to the application drawing operation of a bridge, which bridge leads to binder by server end of Surfaceflinger. [0111] Surfacef linger 负责合成各个surface，然后把buffer 传送到FrameBuffer 端进行底层显不。  [0111] Surfacef linger responsible for the synthesis of each surface, and then transferred to the buffer for the bottom end FrameBuffer not significant. 其中每个surface对应2个buffer，一个frontbuffer, -个back buffer，更新时，数据更新在back buffer上，需要显示时，则将back buffer和front buffer互换。  Wherein each surface corresponding to 2 buffer, a frontbuffer, - a back buffer, updating, the update data in the back buffer, if desired display, then swap back buffer and front buffer. [0112] 此架构的设计主要是要考虑多任务、多窗口、多图层的显示切换与合并，而这些因素在电子白板中可以不用考虑，因此，在图形绘制完毕后去调用显示方法的时候，可以不使用Android提供的上层java方法，而采用JNI的方式直接调用底层的FrameBuffer接口进行与屏，这样能有效提尚显不的速度。  [0112] This architecture is designed primarily to consider the multi-tasking, multi-window display changes and merge multiple layers, and these factors can not be considered in the whiteboard, and therefore, after the graph is plotted the time to call the display method may not be used to provide an upper Android java method, and the use of JNI calls FrameBuffer interface directly with the bottom of the screen, this can not effectively provide still significant velocity. [0113] 在android架构中，所有的设备都是被抽象为文件的，可以通过jni的方式用C语言写一个直接操作framebuffer设备的程序，来将上层将要显示的内容直接发送给FrameBuffer 显不。  [0113] In android architecture, all devices are abstracted as a file, program code can be a direct operation framebuffer device C language by jni manner, to the upper layer content to be displayed directly to FrameBuffer significant not. [0114] 在android系统中，普通应用程序无法直接读取FrameBuffer抽象设备文件，需要将应用程序加android, permission. READ_FRAME_BUFFER 和system 权限并在Android 源码中编译，获得root权限，将/dev/graphics/fbO使用chmod命令修改权限为777,就可以开始使用framebuffer绘图了。  [0114] In the android system, the general application can not directly read FrameBuffer abstract device file, the application will need to add android, permission. READ_FRAME_BUFFER and system permissions and compile Android source code, to gain root privileges, the / dev / graphics / fbO using the chmod command to modify the permissions to 777, you can start using the framebuffer graphics. 具体步骤如下：  Specific steps are as follows: [0115] 1.获得root 权限。  [0115] 1. Obtain root privileges. [0116] 2.使用chmod 将设备/dev/graphics/fbO 权限修改为777。  [0116] 2. chmod device / dev / graphics / fbO modify permission to 777. [0117] 3.使用0_RDWR方式以读写方式打开此设备。  [0117] 3. 0_RDWR way open reading and writing apparatus. [0118] 4.使用ioctl 读取fb_var_screeninfo 和fb_fix_screeninfo 两个结构体信息。  [0118] 4. read fb_var_screeninfo and ioctl fb_fix_screeninfo two information structures. 此步骤主要是取得当前显示屏幕的参数，如屏幕分辨率，每个像素点的比特数。  This step is to obtain parameters for the current main display screen, such as screen resolution, the number of bits per pixel. 根据屏幕参数可计算屏幕缓冲区的大小。  Parameters calculated according to the screen size of screen buffer. [0119] 5.使用mmap方式映射设备内存到进程空间。  [0119] 5. Using mmap device memory mapped into the process space. [0120] 6.将java层传递下来的bitmap数据按照屏幕像素格式写入映射的内存。  [0120] 6. The java layer passed down bitmap data is written to the memory map in accordance with the screen pixel format. [0121] 7.取消内存映射，关闭framebuffer文件句柄。  [0121] 7. cancel memory mapping, framebuffer close the file handle. [0122] 8.在应用程序的AndroidManifest. xml 中加入android: sharedUserld =  " android, uid. system " 属性和android, permission. READ_FRAME_BUFFER 权限，以提升应用程序权限。  . [0122] 8. xml added in android AndroidManifest application:. SharedUserld =  " . Android, uid system "  attribute and android, permission READ_FRAME_BUFFER privilege, permission to improve the application. [0123] 9.将应用程序在Android源码中编译得到相应的APK文件。  [0123] 9. The application files provide the corresponding APK Android compile source code. [0124] 由于从java上层传递到底层的bitmap数据格式应该和framebuffer设备文件中读取到的屏幕数据格式一致，这样可以使用memecpy直接复制，速度较快，不用再进行数据格式转换。  [0124] Since the upper layer is transmitted from the java data format consistent with the underlying bitmap file framebuffer device should be read screen data format, which can be directly used memecpy replication, faster, then no data format conversion. [0125] 在一个实施例中，基于触摸屏的像素设置绘图区域，在内存中创建与绘图区域相映射图文件对象。  [0125] In one embodiment, the touch screen based on a pixel set drawing area, the drawing area and to create a file with a map object in memory. 基于坐标数据在图文件对象中加入在触摸屏上绘制的移动轨迹数据。  Was added based on the coordinate data of the moving route data drawn on the touch screen in FIG file object. 打开一个可用的帧缓冲设备，获取取得当前的触摸屏的参数，触摸屏的参数包括：屏幕分辨率、每个像素点的比特数。  Open frame buffer available device, acquires acquisition parameters, current parameters of the touch screen including a touch screen: screen resolution, the number of bits per pixel. [0126] 将帧缓冲设备的内存映射到内核进程空间。  [0126] mapped frame buffer memory device to a kernel process space. 将图文件对象的数据写入帧缓冲设备的内存，通过帧缓冲设备在触摸屏上相应的位置绘制并显示移动轨迹。  FIG file object data write frame buffer memory device, and a display position corresponding to the movement trajectory drawn on the touch screen through the frame buffer device. [0127] 例如，在电子白板中，Android自带的状态栏有38像素，其余部分就是可以绘图的区域。  [0127] For example, in the whiteboard, Android status bar 38 carrying pixels, drawing the rest of the region is possible. 假如，在可绘图区域绘制了一条线，触摸屏幕像素是1920x1080,可绘图区域是1920x1042。  If, in the drawing area can draw a line, the touch screen is 1920x1080 pixels, the drawing area can be 1920x1042. [0128] 在可绘图区域布局的是一个surfaceview，在启动的时候就创建了一个相应大小的位图对象bitmap :  [0128] In an area of ​​the drawing is a layout surfaceview, at boot time creates a corresponding size of the bitmap object bitmap: [0129] Bitmap bitmap = Bitmap. createBitmap(1920, 1042, Bitmap. Config. RGB_565)；  . [0129] Bitmap bitmap = Bitmap createBitmap (.. 1920, 1042, Bitmap Config RGB_565); [0130] 之后的所有绘图都是在此bitmap中完成，可以在bitmap中加入多个字或绘图。  After all of the drawing [0130] In this bitmap is done, may be added or a plurality of words in the bitmap drawing. [0131] 当绘图完毕需要写入framebuffer显示时，需要如下步骤：  [0131] When the drawing is completed to be written display framebuffer, it requires the steps of: [0132] 1、打开一个可用的FrameBuffer设备。  [0132] 1, open FrameBuffer available device. 实例代码如下：  Example code: [0135] 2、通过ioctl 函数取得fixed screen information。  [0135] 2, fixed screen information acquired by the ioctl function. 实例代码如下：[0136]  Example code is as follows: [0136] [0133]  [0133] [0134] struct fb_var_scre：0nirifo vinfo：; if (ioctKfd, FBIOGETJ ' SCREENINFO,  & finfo)) { exit (2); }  [0134] struct fb_var_scre: 0nirifo vinfo :; if (ioctKfd, FBIOGETJ ' SCREENINFO,  &  finfo)) {exit (2);} [0137] 3、通过ioctl 函数取得variable screen information。  [0137] 3, variable screen information acquired by the ioctl function. 实例代码如下：  Example code: [0138] struct fb_fix screeninfo fi nfo; if (ioctKfd, FBI0GET__VSCREENINF0J:  & vinfo)) { exi t (3); Ί  [0138] struct fb_fix screeninfo fi nfo; if (ioctKfd, FBI0GET__VSCREENINF0J:  &  vinfo)) {exi t (3); Ί [0139] 4、通过_ap函数映射设备内存到进程空间，需要区分内核空间和用户空间，用户空间是无法对物理内存直接读写。  [0139] 4, by _ap function mapping process space to the memory device need to distinguish between kernel space and user space, user space is not directly read and write to the physical memory. 实例代码如下：  Example code: [0140] // Figure out the size of the screen in bytes long screensize = vinfo. xres ^ vinfo, yres ^ vinfo. bits_per_pixel / 8 ;; // Map the device to memory char *fbp = (char 本)mmap(0, screensize); if ((intjfbp =- -1) { exit(4); }  [0140] // Figure out the size of the screen in bytes long screensize = vinfo. Xres ^ vinfo, yres ^ vinfo. Bits_per_pixel / 8 ;; // Map the device to memory char * fbp = (char present) mmap (0 , screensize); if ((intjfbp = - -1) {exit (4);} [0141] 5、将bitmap数据写入对应的framebuffer位置具体步骤如下：  [0141] 5, framebuffer position of the bitmap data is written to specific steps corresponding to the following: [0142] a.先将bitmap数据转为byte []数组。  [0142] a. Bitmap data into first byte [] array. 实例代码如下：  Example code: [0143] public byte[] getBitmapByte(Bitmap bitmap) {  [0143] public byte [] getBitmapByte (Bitmap bitmap) { [0144] ByteArrayQutputStream out = new ByteArrayQutputStreamO; bitmap, compress(Bitmap, CompressFormat. JPEG, 100, out); try { out. flush ();： out. close(); } catch (lOException e) { e. printStackTrace (); } return out. toByteArray(); }  [0144] ByteArrayQutputStream out = new ByteArrayQutputStreamO; bitmap, compress (. Bitmap, CompressFormat JPEG, 100, out); try {.. Out flush () ;: out close ();}. Catch (lOException e) {e printStackTrace ( );} return out toByteArray ();.} [0145] b.通过jni将byte □从java层传给c层，转换为char []数组。  [0145] b. Jni by the transmitted byte □ c java layer from the layer, is converted to char [] array. [0146] c.因为Android的状态栏占据了38像素的位置，需要找到相应的起始点位置。  [0146] c. Android because the status bar 38 occupies the positions of pixels, need to find appropriate position of start point. 采用rgb565格式，一个像素占用2个字节，那么状态栏总共占用的字节数为：  Using rgb565 format, a pixel occupies two bytes, then the total number of bytes in the status bar is occupied by: [0147] long offset = 1920*38*2 ;  [0147] long offset = 1920 * 38 * 2; [0148] 采用memcpy的方式将数据写入framebuffer :  [0148] The way to write data memcpy framebuffer: [0149] memcpy ((void*) (fbp+offset), *src, screensize-offset)；  [0149] memcpy ((void *) (fbp + offset), * src, screensize-offset); [0150] 其中：fbp为framebuffer地址，src为源数据地址。  [0150] wherein: fbp is framebuffer address, src as the source address of the data. [0151] 6、结束，取消映射，并close掉句柄。  [0151] 6, the end, unmapped, and close off the handle. 实例代码如下：  Example code: [0152] munmap (fbp, screensize)；  [0152] munmap (fbp, screensize); [0153] close (fd)；  [0153] close (fd); [0154] 绘图数据就能在相应的位置正确显示了。  [0154] drawing data can be displayed correctly in the corresponding position. [0155] 通过上述实施例中的绘图方法，能够明显提升显示数据的速度。  [0155] By drawing the above-described embodiments of the method, can significantly enhance the speed of the display data. [0156] 如图6所示，本发明提供一种电子白板的书写装置3。  [0156] As shown in FIG 6, the present invention provides an electronic whiteboard writing device 3. 设备文件获取单元31获取与电子白板的触摸屏相对应的触摸屏设备文件。  Device file acquiring unit 31 acquires the touch screen whiteboard touch screen corresponding device file. 轨迹数据计算单元32读取触摸屏设备文件，从触摸屏设备文件中获取触摸事件数据；根据触摸事件数据计算在触摸屏上显示的轨迹数据。  Trajectory calculation unit 32 reads data of a touch screen device file, acquires a touch event data from the touchscreen device file; calculating trajectory data displayed on the touch screen according to the touch event data. 轨迹绘制单元33调用帧缓冲区接口，基于轨迹数据在触摸屏上绘制移动轨迹。  Locus drawing frame buffer unit 33 calls the interface, the movement trajectory drawn on the touch screen based on the trajectory data. [0157] 轨迹数据计算单元32启动触摸数据获取线程；触摸数据读取触摸屏设备文件， 从触摸屏设备文件中获取触摸事件数据，并根据触摸事件数据计算在触摸屏上显示的轨迹数据。  [0157] trajectory data calculating unit 32 to start the data acquisition thread touch; touch data file reading the touch screen device, a touch event data acquired from the touch screen device file, and calculates the trajectory data displayed on the touch screen according to the touch event data. 轨迹绘制单元33启动轨迹绘制线程；轨迹绘制线程调用帧缓冲区接口，基于轨迹数据在触摸屏上绘制移动轨迹。  Locus drawing unit 33 to draw the thread start track; locus drawing frame buffer thread calls the interface, the movement trajectory drawn on the touch screen based on the trajectory data. [0158] 在一个实施例中，设备文件获取单元31打开系统中存储设备文件的目录，遍历此目录下所有的设备文件；依次打开设备文件，得到此设备文件的句柄并获取此设备文件的设备名称；判断此设备文件的设备名称是否与触摸屏设备的设备名称一致，如果是，则此设备文件为触摸屏设备文件，保存触摸屏设备文件的句柄。  [0158] In one embodiment, the device file retrieval 31 is opened directory system storage file unit, through all the device files in this directory; turn open the device file, to obtain a handle to the device file and acquires the equipment This document name; the name of this device to determine the device file is consistent with the device name touch screen devices, if it is, the device file for the touch screen device file, save the file handle touch-screen device. [0159] 在一个实施例中，事件获取子模块321周期性地读取触摸屏设备文件，获取触摸屏设备文件中的事件数据；在触摸屏上操作的事件数据被存储在触摸屏设备文件中。  [0159] In one embodiment, the event acquisition sub-module 321 periodically reads the file touch screen device, a touch screen device acquires event data file; event data on a touch screen of a touch screen device is stored in a file. 坐标计算子模块322解析事件数据，并将事件数据封装为触摸屏上的移动轨迹的坐标数据。  Coordinate calculation sub-module 322 parses the event data and event data package to the movement trajectory on the touch screen coordinate data. [0160] 坐标计算单元322解析事件数据获取事件参数，事件参数包括：事件ID、操作类型、X坐标采样值、γ坐标采样值；将事件参数转换为移动轨迹的坐标数据，坐标数据包括： 轨迹ID、触摸屏X坐标、触摸屏7坐标和当前操作状态；当前操作状态包括：上、下、移动；其中，当触摸屏的分辨率为在X轴方向上为W像素、在Y轴方向上为Η像素时：  [0160] The coordinate calculation unit 322 parses the event data acquisition event parameters, event parameters include: event ID, type of, X coordinate sampling values, gamma] coordinate sampled value; event parameters into the coordinate data of the trajectories of the coordinate data comprising: trace ID, touch-screen X-coordinate, a touch screen 7 coordinates and the current operating state; current operating state comprising: upper and lower, moved; wherein, when the resolution of the touch screen of the X-axis direction is W pixels in the Y-axis direction Η pixels Time: [0161]  [0161] [0162] XL为触摸屏X标，XT为X坐标采样值，Xtmin、Xtmax、分别是触摸屏的X、Υ轴方向上的坐标最小值和坐标最大值；  [0162] XL X marked as a touch screen, XT coordinate for the sample value X, Xtmin, Xtmax, respectively, the touch screen X, coordinates of the minimum and maximum coordinates in the Υ-axis direction; [0163]  [0163] %  % [0164] YL为触摸屏Y坐标，YT是Y坐标采样值，Ytmin、Ytmax分别是触摸屏的Y轴方向上的坐标最小值和坐标最大值。  [0164] YL Y coordinate for the touch screen, YT is a Y coordinate sampling values, Ytmin, Ytmax coordinates are the coordinates of the minimum and maximum values ​​on the Y-axis direction of the touch screen. [0165] 在一个实施例中，图文件创建子模块331基于触摸屏的像素设置绘图区域，在内存中创建与绘图区域相映射图文件对象。  [0165] In one embodiment, FIG file creation module 331 based on sub-pixel arranged in the drawing area of ​​the touch screen, to create a map drawing area with an object file in memory. 运行轨迹生成子模块332基于坐标数据在图文件对象中加入在触摸屏上绘制的移动轨迹数据；帧缓冲设备调用子模块333打开一个可用的帧缓冲设备，获取取得当前的触摸屏的参数，触摸屏的参数包括：屏幕分辨率、每个像素点的比特数；将帧缓冲设备的内存映射到内核进程空间；将图文件对象的数据写入帧缓冲设备的内存，通过帧缓冲设备在触摸屏上相应的位置绘制并显示移动轨迹。  Trajectory generation sub-module 332 based on the coordinate data into the moving route data drawn on the touch screen in FIG file object; framebuffer device calls the sub-module 333 opens the framebuffer available device, acquires acquisition parameters of the current touch screen, parameters of the touch screen comprising: a screen resolution, the number of bits per pixel; the frame buffer memory devices mapped into the kernel process space; FIG file object data into memory device frame buffer, the frame buffer by the device corresponding to a position on the touch screen rendering and displaying the trajectories. [0166] 上述实施例提供的电子白板的书写方法及装置，能够直接从触摸屏设备文件中得到点击的事件，直接调用底层的帧缓存接口进行写屏操作，并将获取触摸事件和写屏操作分别放在2个线程完成的，提高了运行效率并提升书写速度，解决了书写轨迹偏差的问题， 并明显提升了显示数据的速度，提高了电子产品的用户感受度，提升了产品质量和竞争力。  [0166] The embodiment provides a method and apparatus for writing electronic whiteboard, click event can be obtained directly from the touchscreen device file, directly call the underlying screen frame buffer interface write operation, write the acquired touch screen operation event and respectively on two threads to finish, improved operating efficiency and enhance the writing speed, writing to solve the problem of route deviation, and significantly improved the speed of the display data to improve the user experience of electronic products, improve product quality and competitiveness . [0167] 所属领域的普通技术人员应当理解：以上所述仅为本发明的具体实施例而已，并不用于限制本发明，凡在本发明的精神和原则之内，所做的任何修改、等同替换、改进等，均应包含在本发明的保护范围之内。  [0167] Those of ordinary skill in the art should be understood: The above specific embodiments of the present invention, it is only, not intended to limit the present invention, all within the spirit and principle of the present invention, any changes made, equivalent Alternatively, modifications all fall within the protection scope of the present invention. 